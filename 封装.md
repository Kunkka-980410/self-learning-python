## 封装
封装（Encapsulation）。它是 Python 类设计的基础，也是写出高质量代码的关键。  

**🧠 什么是封装？**
封装指的是：把数据（属性）和操作数据的方法（函数）绑定在一起，并隐藏内部实现细节，只暴露必要的接口给外部使用。

简单说就是：

“把复杂的东西藏起来，只给别人看你想让他看的部分。”  
✅ 封装的三个关键点
|特性	|说明|	Python实现方式
|---|---|---
|数据隐藏	|不让外部直接访问内部数据	|使用私有属性`（__xxx）`
|接口暴露|	提供方法让外部安全访问数据	|使用 `getter/setter` 方法
|内部控制|	类内部可以自由操作自己的数据	|用 `self` 管理属性  

🧪 示例：银行账户类
```python
class BankAccount:
    def __init__(self, owner, balance):
        self.owner = owner
        self.__balance = balance  # 私有属性

    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount

    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount

    def get_balance(self):
        return self.__balance
```
调用方式：

```python
acc = BankAccount("权", 1000)
acc.deposit(500)
acc.withdraw(200)
print(acc.get_balance())  # 输出：1300
```
你不能直接访问 `acc.__balance`，因为它是私有的，但可以通过 `get_balance()` 安全获取。  
🔐 为什么封装很重要？
✅ 提高安全性：防止外部随意修改内部状态

✅ 降低耦合度：外部只依赖接口，不关心内部实现

✅ 易于维护：修改内部逻辑不会影响外部调用

✅ 支持权限控制：可以设置只读、只写、可修改等访问方式

✅ 总结一句话：
封装就是把数据和方法包在类里，隐藏细节、暴露接口，让代码更安全、更清晰、更易维护。

---
## Python 中如何实现封装（Encapsulation）

**🧠 封装的核心思想**
把数据和操作数据的方法“包”在类里，隐藏内部细节，只暴露安全的接口。  

✅ 封装的三步走  

1️⃣ 定义私有属性（隐藏数据）
使用双下划线 `__ `开头，让属性变成私有：

```python
class Student:
    def __init__(self, name, score):
        self.name = name            # 公有属性
        self.__score = score        # 私有属性
```
外部不能直接访问 `__score`，这是封装的第一步。

2️⃣ 提供公开方法（暴露接口）
通过方法来安全访问或修改私有属性：

```python
    def get_score(self):
        return self.__score

    def set_score(self, value):
        if 0 <= value <= 100:
            self.__score = value
        else:
            print("Invalid score")
```
这样你就控制了数据的访问方式，避免外部乱改。

3️⃣ 使用对象调用接口
```python
s = Student("权", 85)
print(s.get_score())     # 输出：85

s.set_score(95)
print(s.get_score())     # 输出：95

s.set_score(150)         # 输出：Invalid score
```
你不能直接访问 `s.__score`，但可以通过 `get_score()` 和 `set_score()` 来安全操作。

---
## property来调用封装的变量  
**🧠 为什么用 `@property`？**
在封装中，我们通常把变量设为私有（如 `__score`），然后通过方法访问它。但这样写：

```python
print(student.get_score())
```
不如这样自然：

```python
print(student.score)
```
这就是 `@property` 的作用：让方法像属性一样被调用。

✅ 实战示例：用 `@property` 封装变量
```python
class Student:
    def __init__(self, name, score):
        self.name = name
        self.__score = score  # 私有变量

    @property
    def score(self):         # getter
        return self.__score

    @score.setter
    def score(self, value):  # setter
        if 0 <= value <= 100:
            self.__score = value
        else:
            raise ValueError("Score must be between 0 and 100")
```
🔧 使用方式
```python
s = Student("权", 88)

print(s.score)     # 自动调用 getter，输出：88

s.score = 95       # 自动调用 setter，修改值

print(s.score)     # 输出：95

s.score = 150      # 报错：ValueError
```
虽然我们调用的是 `s.score`，但实际上背后是方法在运行。这就是属性方法的魔力。

✅ 总结一句话：
`@property` 让你在封装中既能隐藏数据，又能优雅地访问和修改它，像属性一样调用方法，
